<script>
  /************************************
   * 0. SPLASH / ANIMATION
   ************************************/
  function hideSplashScreen() {
    const splash = document.getElementById('splash-screen');
    if (!splash) return;
    setTimeout(() => {
      splash.classList.add('fade-out');
    }, 1800); // ~1.8s branded moment
  }

  /************************************
   * 1. DATE / HELPERS
   ************************************/
  function todayISO() {
    const d = new Date();
    return [
      d.getFullYear(),
      String(d.getMonth()+1).padStart(2,"0"),
      String(d.getDate()).padStart(2,"0")
    ].join("-");
  }
  function fmtDate(iso) {
    const [y,m,d] = iso.split("-");
    return `${d}-${m}-${y}`;
  }
  function shiftDate(iso,days){
    const [y,m,d]=iso.split("-");
    const base=new Date(Number(y),Number(m)-1,Number(d));
    base.setDate(base.getDate()+days);
    return [
      base.getFullYear(),
      String(base.getMonth()+1).padStart(2,"0"),
      String(base.getDate()).padStart(2,"0")
    ].join("-");
  }
  function nowTime() {
    const d = new Date();
    const hh = String(d.getHours()).padStart(2,"0");
    const mm = String(d.getMinutes()).padStart(2,"0");
    return `${hh}:${mm}`;
  }

  /************************************
   * 2. LOCAL STORAGE BACKUP
   ************************************/
  function loadTasksLocal(){
    return JSON.parse(localStorage.getItem('tp_tasks')||'[]');
  }
  function saveTasksLocal(list){
    localStorage.setItem('tp_tasks',JSON.stringify(list));
  }
  function getSyncCodeLocal(){
    return localStorage.getItem('tp_sync_code')||null;
  }
  function setSyncCodeLocal(code){
    localStorage.setItem('tp_sync_code',code);
  }
  function getLastRolloverDate(){
    return localStorage.getItem('tp_last_rollover')||"";
  }
  function setLastRolloverDate(d){
    localStorage.setItem('tp_last_rollover', d);
  }

  function createTask({name,priority,dateAssigned,status,timeCompleted,rating}) {
    return {
      id:'t_'+Math.random().toString(36).slice(2,9),
      name,
      priority,
      status: status || 'not done',
      timeCompleted: timeCompleted || '',
      dateAssigned: dateAssigned || todayISO(),
      rating: (typeof rating === "number" ? rating : 0) // 0-3 stars
    };
  }

  /************************************
   * 3. FIREBASE CONFIG (already yours)
   ************************************/
  const firebaseConfig = {
    apiKey: "AIzaSyDXbxWT9viGCGDpPxlzp45QaBr3zUUn2UU",
    authDomain: "taskpulse-9a6ab.firebaseapp.com",
    databaseURL: "https://taskpulse-9a6ab-default-rtdb.firebaseio.com",
    projectId: "taskpulse-9a6ab",
    storageBucket: "taskpulse-9a6ab.firebasestorage.app",
    messagingSenderId: "92117591983",
    appId: "1:92117591983:web:dd1d73226dbb112c58f15a",
    measurementId: "G-SN3T2B2RMY"
  };

  firebase.initializeApp(firebaseConfig);
  const auth = firebase.auth();
  const db   = firebase.database();

  let currentUser    = null;
  let activeSyncCode = null; // "room" / shared list id

  function tasksRef(){
    if(!activeSyncCode) return null;
    return db.ref("tasklists/"+activeSyncCode+"/tasks");
  }

  /************************************
   * 4. CLOUD SYNC
   ************************************/
  function downloadTasksFromCloud(){
    if(!tasksRef()) return;
    tasksRef().once("value").then(snap=>{
      const data = snap.val() || {};
      const arr  = Object.values(data);
      saveTasksLocal(arr);
      renderAll();
    });
  }

  function uploadTasksToCloud(){
    if(!tasksRef()) return;
    const localTasks = loadTasksLocal();
    const obj = {};
    for(const t of localTasks){
      obj[t.id] = t;
    }
    tasksRef().set(obj);
  }

  function startRealtimeSync(){
    if(!tasksRef()) return;
    tasksRef().on("value", snap => {
      const data = snap.val() || {};
      const arr = Object.values(data);
      saveTasksLocal(arr);
      renderAll();
    });
  }

  /************************************
   * 5. AUTH + SYNC CODE BOOT
   ************************************/
  function ensureSignedInAnon(){
    return new Promise((resolve,reject)=>{
      if(currentUser){
        resolve(currentUser);
        return;
      }
      auth.signInAnonymously()
        .then(cred=>{
          currentUser = cred.user;
          resolve(currentUser);
        })
        .catch(err=>reject(err));
    });
  }

  function initSyncCode(){
    // try existing
    let code = getSyncCodeLocal();
    if(!code){
      // make new code from uid prefix
      const short = currentUser && currentUser.uid
        ? currentUser.uid.slice(0,6)
        : Math.random().toString(36).slice(2,8);
      code = "grp-"+short;
      setSyncCodeLocal(code);
    }
    activeSyncCode = code;

    const syncField = document.getElementById("syncCodeDisplay");
    if(syncField){
      syncField.value = activeSyncCode;
    }
  }

  function joinSyncCode(newCode){
    if(!newCode) return;
    activeSyncCode = newCode;
    setSyncCodeLocal(newCode);

    const syncField = document.getElementById("syncCodeDisplay");
    if(syncField){
      syncField.value = activeSyncCode;
    }

    // join shared room
    startRealtimeSync();
    downloadTasksFromCloud();
    uploadTasksToCloud();
  }

  /************************************
   * 6. ROLLOVER: carry unfinished tasks to today
   ************************************/
  function rolloverUnfinishedFromYesterday(){
    const today = todayISO();
    const lastRollover = getLastRolloverDate();

    // Only run once per calendar day
    if(lastRollover === today){
      return;
    }

    const yesterday = shiftDate(today, -1);
    const tasks = loadTasksLocal();

    // Check if today already has tasks (so we don't keep cloning if you manually ran join)
    const todaysTasks = tasks.filter(t => t.dateAssigned === today);
    // We'll still roll over even if today isn't empty, because you might add morning tasks manually.
    // We just avoid DUPLICATING same carry-forwards twice in the same day by using tp_last_rollover.

    // Find yesterday's unfinished
    const unfinished = tasks.filter(t =>
      t.dateAssigned === yesterday &&
      t.status !== "done"
    );

    if(unfinished.length > 0){
      for(const oldTask of unfinished){
        const newTask = createTask({
          name: oldTask.name,
          priority: oldTask.priority,
          dateAssigned: today,
          status: "not done",
          timeCompleted: "",
          rating: typeof oldTask.rating === "number" ? oldTask.rating : 0
        });
        tasks.push(newTask);
      }
      saveTasksLocal(tasks);
      uploadTasksToCloud(); // push new rolled tasks up so other devices see them
    }

    setLastRolloverDate(today);
  }

  /************************************
   * 7. TASK ACTIONS (done / delete / rate / add)
   ************************************/
  function escapeHTML(str){
    return str.replace(/[&<>"]/g, c=>({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;"}[c]));
  }

  function toggleTaskDone(id){
    const tasks = loadTasksLocal();
    const idx   = tasks.findIndex(t=>t.id===id);
    if(idx<0) return;

    const task = tasks[idx];
    if(task.status==="done"){
      task.status="not done";
      task.timeCompleted="";
    } else {
      task.status="done";
      task.timeCompleted=nowTime();
    }

    saveTasksLocal(tasks);
    renderAll();
    uploadTasksToCloud();
  }

  function deleteTask(id){
    let tasks = loadTasksLocal();
    tasks = tasks.filter(t => t.id !== id);
    saveTasksLocal(tasks);
    renderAll();
    uploadTasksToCloud();
  }

  function setRating(id, newRating){
    const tasks = loadTasksLocal();
    const idx   = tasks.findIndex(t=>t.id===id);
    if(idx<0) return;
    tasks[idx].rating = newRating; // 0..3
    saveTasksLocal(tasks);
    renderAll();
    uploadTasksToCloud();
  }

  function addTask(){
    const nameInput = document.getElementById("newTaskName");
    const prioSel   = document.getElementById("newTaskPriority");
    const nm        = nameInput.value.trim();
    const pr        = prioSel.value;
    if(!nm) return;

    const tasks = loadTasksLocal();
    tasks.push(createTask({
      name:nm,
      priority:pr,
      rating:0
    }));
    saveTasksLocal(tasks);

    nameInput.value = "";
    prioSel.value   = "low";

    renderAll();
    uploadTasksToCloud();
  }

  /************************************
   * 8. RENDER UI (Today + History)
   ************************************/
  let historyDate = todayISO();

  function renderHeaderToday(){
    document.getElementById("todayDate").textContent = fmtDate(todayISO());
  }

  function renderTodayList(){
    const listEl   = document.getElementById("todayTaskList");
    const statsEl  = document.getElementById("todayStats");
    const allTasks = loadTasksLocal();
    const today    = todayISO();

    const todaysTasks = allTasks.filter(t=>t.dateAssigned===today);
    const doneCt      = todaysTasks.filter(t=>t.status==="done").length;
    const totalCt     = todaysTasks.length;
    const pct         = totalCt?Math.round((doneCt/totalCt)*100):0;

    statsEl.textContent = `${doneCt} / ${totalCt} done (${pct}%)`;

    // Star rating UI builder
    function starsHTML(task){
      const r = typeof task.rating === "number" ? task.rating : 0;
      // 3 tappable stars: index 1..3
      let out = '<div class="task-meta" style="margin-top:4px; font-size:0.8rem; color:#444;">';
      for(let i=1;i<=3;i++){
        out += `<span data-role="setRating" data-id="${task.id}" data-rating="${i}" style="cursor:pointer;user-select:none;">${i<=r ? "★":"☆"}</span> `;
      }
      out += '</div>';
      return out;
    }

    listEl.innerHTML = todaysTasks.map(t=>{
      const isDone = t.status==="done";
      const prClass = t.priority==="high"
        ? "priority-high"
        : t.priority==="med"
        ? "priority-med"
        : "priority-low";

      return `
        <div class="task-row" data-id="${t.id}">
          <div style="display:flex;align-items:flex-start;gap:10px;flex:1;">
            <div class="task-check ${isDone?"done":""}" data-role="toggleTask">${isDone?"✓":""}</div>
            <div style="flex:1;">
              <div>
                <span class="task-name">${escapeHTML(t.name)}</span>
                <span class="priority-pill ${prClass}">${t.priority}</span>
              </div>
              <div class="task-meta">
                ${isDone
                  ? "✔ Done at " + (t.timeCompleted||"—")
                  : "Not done"}
              </div>
              ${starsHTML(t)}
            </div>
          </div>

          <button
            class="settings-action"
            style="background:#fff;color:#1d1d1f;border:1px solid #cfcfd3;min-width:44px;min-height:36px;font-size:.8rem;border-radius:10px;"
            data-role="deleteTask"
          >🗑</button>
        </div>
      `;
    }).join("");

    // bind toggle done
    listEl.querySelectorAll('[data-role="toggleTask"]').forEach(el=>{
      el.onclick = ()=>{
        const row = el.closest(".task-row");
        const id  = row.dataset.id;
        toggleTaskDone(id);
      };
    });

    // bind delete
    listEl.querySelectorAll('[data-role="deleteTask"]').forEach(btn=>{
      btn.onclick = ()=>{
        const row = btn.closest(".task-row");
        const id  = row.dataset.id;
        deleteTask(id);
      };
    });

    // bind rating
    listEl.querySelectorAll('[data-role="setRating"]').forEach(star=>{
      star.onclick = ()=>{
        const id  = star.getAttribute("data-id");
        const val = Number(star.getAttribute("data-rating"));
        setRating(id, val);
      };
    });
  }

  function renderHistory(){
    const tasks    = loadTasksLocal();
    const dayTasks = tasks.filter(t=>t.dateAssigned===historyDate);
    const doneCt   = dayTasks.filter(t=>t.status==="done").length;
    const pct      = dayTasks.length?Math.round((doneCt/dayTasks.length)*100):0;

    document.getElementById("historyDateLabel").textContent = fmtDate(historyDate);
    document.getElementById("historyStats").textContent =
      `${doneCt} / ${dayTasks.length} tasks done (${pct}%)`;

    document.getElementById("historyTaskList").innerHTML = dayTasks.map(t=>{
      return `<div class="small" style="color:#444;">
        • ${escapeHTML(t.name)} (${t.priority}) — ${t.status} ${typeof t.rating==="number" ? ` [${t.rating}★]` : ""}
      </div>`;
    }).join("");
  }

  /************************************
   * 9. SYNC UI BINDINGS
   ************************************/
  function bindSyncUI(){
    const copyBtn=document.getElementById("copySyncCodeBtn");
    const joinBtn=document.getElementById("joinSyncBtn");

    if(copyBtn){
      copyBtn.onclick=()=>{
        const field=document.getElementById("syncCodeDisplay");
        if(field && field.value){
          navigator.clipboard.writeText(field.value);
        }
      };
    }

    if(joinBtn){
      joinBtn.onclick=()=>{
        const field=document.getElementById("syncCodeInput");
        if(field && field.value.trim()){
          joinSyncCode(field.value.trim());
          field.value="";
        }
      };
    }
  }

  /************************************
   * 10. RENDER ALL
   ************************************/
  function renderAll(){
    renderHeaderToday();
    renderTodayList();
    renderHistory();
  }

  /************************************
   * 11. INIT
   ************************************/
  function init(){
    hideSplashScreen();

    // bind UI controls
    document.getElementById("addTaskBtn").onclick = addTask;
    document.getElementById("prevDayBtn").onclick = ()=>{
      historyDate = shiftDate(historyDate,-1);
      renderAll();
    };
    document.getElementById("nextDayBtn").onclick = ()=>{
      historyDate = shiftDate(historyDate,1);
      renderAll();
    };
    bindSyncUI();

    // sign in, sync, rollover unfinished tasks from yesterday once per day
    ensureSignedInAnon()
      .then(()=>{
        initSyncCode();          // sets activeSyncCode + puts it in the UI
        rolloverUnfinishedFromYesterday(); // clone unfinished -> today
        startRealtimeSync();     // live listener to shared room
        downloadTasksFromCloud();// pull shared tasks
        uploadTasksToCloud();    // push local snapshot up
      })
      .catch(err=>{
        console.log("Auth/sync error. Local-only fallback.", err);
        // local still works
        rolloverUnfinishedFromYesterday();
      })
      .finally(()=>{
        renderAll();
      });

    // service worker for offline
    if("serviceWorker" in navigator){
      navigator.serviceWorker.register("sw.js");
    }
  }

  init();
</script>
